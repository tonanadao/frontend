{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeBlockId = exports.encodeVersion = exports.encodeBytes = exports.encodeTime = exports.encodeInt = exports.encodeString = exports.Integer = exports.dictionaryToStringMap = exports.may = exports.optional = exports.assertNotEmpty = exports.assertObject = exports.assertArray = exports.assertNumber = exports.assertString = exports.assertBoolean = exports.assertSet = void 0;\nvar encoding_1 = require(\"@cosmjs/encoding\");\nvar math_1 = require(\"@cosmjs/math\");\n/**\n * A runtime checker that ensures a given value is set (i.e. not undefined or null)\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n */\nfunction assertSet(value) {\n  if (value === undefined) {\n    throw new Error(\"Value must not be undefined\");\n  }\n  if (value === null) {\n    throw new Error(\"Value must not be null\");\n  }\n  return value;\n}\nexports.assertSet = assertSet;\n/**\n * A runtime checker that ensures a given value is a boolean\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\nfunction assertBoolean(value) {\n  assertSet(value);\n  if (typeof value !== \"boolean\") {\n    throw new Error(\"Value must be a boolean\");\n  }\n  return value;\n}\nexports.assertBoolean = assertBoolean;\n/**\n * A runtime checker that ensures a given value is a string.\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\nfunction assertString(value) {\n  assertSet(value);\n  if (typeof value !== \"string\") {\n    throw new Error(\"Value must be a string\");\n  }\n  return value;\n}\nexports.assertString = assertString;\n/**\n * A runtime checker that ensures a given value is a number\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\nfunction assertNumber(value) {\n  assertSet(value);\n  if (typeof value !== \"number\") {\n    throw new Error(\"Value must be a number\");\n  }\n  return value;\n}\nexports.assertNumber = assertNumber;\n/**\n * A runtime checker that ensures a given value is an array\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\nfunction assertArray(value) {\n  assertSet(value);\n  if (!Array.isArray(value)) {\n    throw new Error(\"Value must be a an array\");\n  }\n  return value;\n}\nexports.assertArray = assertArray;\n/**\n * A runtime checker that ensures a given value is an object in the sense of JSON\n * (an unordered collection of key–value pairs where the keys are strings)\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\nfunction assertObject(value) {\n  assertSet(value);\n  if (typeof value !== \"object\") {\n    throw new Error(\"Value must be an object\");\n  }\n  // Exclude special kind of objects like Array, Date or Uint8Array\n  // Object.prototype.toString() returns a specified value:\n  // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring\n  if (Object.prototype.toString.call(value) !== \"[object Object]\") {\n    throw new Error(\"Value must be a simple object\");\n  }\n  return value;\n}\nexports.assertObject = assertObject;\n/**\n * Throws an error if value matches the empty value for the\n * given type (array/string of length 0, number of value 0, ...)\n *\n * Otherwise returns the value.\n *\n * This implies assertSet\n */\nfunction assertNotEmpty(value) {\n  assertSet(value);\n  if (typeof value === \"number\" && value === 0) {\n    throw new Error(\"must provide a non-zero value\");\n  } else if (value.length === 0) {\n    throw new Error(\"must provide a non-empty value\");\n  }\n  return value;\n}\nexports.assertNotEmpty = assertNotEmpty;\n// optional uses the value or provides a default\nfunction optional(value, fallback) {\n  return value === undefined || value === null ? fallback : value;\n}\nexports.optional = optional;\n// may will run the transform if value is defined, otherwise returns undefined\nfunction may(transform, value) {\n  return value === undefined || value === null ? undefined : transform(value);\n}\nexports.may = may;\nfunction dictionaryToStringMap(obj) {\n  var out = new Map();\n  for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    var value = obj[key];\n    if (typeof value !== \"string\") {\n      throw new Error(\"Found dictionary value of type other than string\");\n    }\n    out.set(key, value);\n  }\n  return out;\n}\nexports.dictionaryToStringMap = dictionaryToStringMap;\nvar Integer = /*#__PURE__*/function () {\n  function Integer() {\n    _classCallCheck(this, Integer);\n  }\n  _createClass(Integer, null, [{\n    key: \"parse\",\n    value: function parse(input) {\n      var asInt = typeof input === \"number\" ? new math_1.Int53(input) : math_1.Int53.fromString(input);\n      return asInt.toNumber();\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(num) {\n      return new math_1.Int53(num).toString();\n    }\n  }]);\n  return Integer;\n}();\nexports.Integer = Integer;\n// Encodings needed for hashing block headers\n// Several of these functions are inspired by https://github.com/nomic-io/js-tendermint/blob/tendermint-0.30/src/\n// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L193-L195\nfunction encodeString(s) {\n  var utf8 = (0, encoding_1.toUtf8)(s);\n  return Uint8Array.from([utf8.length].concat(_toConsumableArray(utf8)));\n}\nexports.encodeString = encodeString;\n// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L79-L87\nfunction encodeInt(n) {\n  // eslint-disable-next-line no-bitwise\n  return n >= 0x80 ? Uint8Array.from([n & 0xff | 0x80].concat(_toConsumableArray(encodeInt(n >> 7)))) : Uint8Array.from([n & 0xff]);\n}\nexports.encodeInt = encodeInt;\n// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L134-L178\nfunction encodeTime(time) {\n  var milliseconds = time.getTime();\n  var seconds = Math.floor(milliseconds / 1000);\n  var secondsArray = seconds ? [0x08].concat(_toConsumableArray(encodeInt(seconds))) : new Uint8Array();\n  var nanoseconds = (time.nanoseconds || 0) + milliseconds % 1000 * 1e6;\n  var nanosecondsArray = nanoseconds ? [0x10].concat(_toConsumableArray(encodeInt(nanoseconds))) : new Uint8Array();\n  return Uint8Array.from([].concat(_toConsumableArray(secondsArray), _toConsumableArray(nanosecondsArray)));\n}\nexports.encodeTime = encodeTime;\n// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L180-L187\nfunction encodeBytes(bytes) {\n  // Since we're only dealing with short byte arrays we don't need a full VarBuffer implementation yet\n  if (bytes.length >= 0x80) throw new Error(\"Not implemented for byte arrays of length 128 or more\");\n  return bytes.length ? Uint8Array.from([bytes.length].concat(_toConsumableArray(bytes))) : new Uint8Array();\n}\nexports.encodeBytes = encodeBytes;\nfunction encodeVersion(version) {\n  var blockArray = version.block ? Uint8Array.from([0x08].concat(_toConsumableArray(encodeInt(version.block)))) : new Uint8Array();\n  var appArray = version.app ? Uint8Array.from([0x10].concat(_toConsumableArray(encodeInt(version.app)))) : new Uint8Array();\n  return Uint8Array.from([].concat(_toConsumableArray(blockArray), _toConsumableArray(appArray)));\n}\nexports.encodeVersion = encodeVersion;\nfunction encodeBlockId(blockId) {\n  return Uint8Array.from([0x0a, blockId.hash.length].concat(_toConsumableArray(blockId.hash), [0x12, blockId.parts.hash.length + 4, 0x08, blockId.parts.total, 0x12, blockId.parts.hash.length], _toConsumableArray(blockId.parts.hash)));\n}\nexports.encodeBlockId = encodeBlockId;","map":{"version":3,"sources":["../../src/tendermint34/encodings.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeBlockId = exports.encodeVersion = exports.encodeBytes = exports.encodeTime = exports.encodeInt = exports.encodeString = exports.Integer = exports.dictionaryToStringMap = exports.may = exports.optional = exports.assertNotEmpty = exports.assertObject = exports.assertArray = exports.assertNumber = exports.assertString = exports.assertBoolean = exports.assertSet = void 0;\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\n/**\n * A runtime checker that ensures a given value is set (i.e. not undefined or null)\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n */\nfunction assertSet(value) {\n    if (value === undefined) {\n        throw new Error(\"Value must not be undefined\");\n    }\n    if (value === null) {\n        throw new Error(\"Value must not be null\");\n    }\n    return value;\n}\nexports.assertSet = assertSet;\n/**\n * A runtime checker that ensures a given value is a boolean\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\nfunction assertBoolean(value) {\n    assertSet(value);\n    if (typeof value !== \"boolean\") {\n        throw new Error(\"Value must be a boolean\");\n    }\n    return value;\n}\nexports.assertBoolean = assertBoolean;\n/**\n * A runtime checker that ensures a given value is a string.\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\nfunction assertString(value) {\n    assertSet(value);\n    if (typeof value !== \"string\") {\n        throw new Error(\"Value must be a string\");\n    }\n    return value;\n}\nexports.assertString = assertString;\n/**\n * A runtime checker that ensures a given value is a number\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\nfunction assertNumber(value) {\n    assertSet(value);\n    if (typeof value !== \"number\") {\n        throw new Error(\"Value must be a number\");\n    }\n    return value;\n}\nexports.assertNumber = assertNumber;\n/**\n * A runtime checker that ensures a given value is an array\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\nfunction assertArray(value) {\n    assertSet(value);\n    if (!Array.isArray(value)) {\n        throw new Error(\"Value must be a an array\");\n    }\n    return value;\n}\nexports.assertArray = assertArray;\n/**\n * A runtime checker that ensures a given value is an object in the sense of JSON\n * (an unordered collection of key–value pairs where the keys are strings)\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\nfunction assertObject(value) {\n    assertSet(value);\n    if (typeof value !== \"object\") {\n        throw new Error(\"Value must be an object\");\n    }\n    // Exclude special kind of objects like Array, Date or Uint8Array\n    // Object.prototype.toString() returns a specified value:\n    // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring\n    if (Object.prototype.toString.call(value) !== \"[object Object]\") {\n        throw new Error(\"Value must be a simple object\");\n    }\n    return value;\n}\nexports.assertObject = assertObject;\n/**\n * Throws an error if value matches the empty value for the\n * given type (array/string of length 0, number of value 0, ...)\n *\n * Otherwise returns the value.\n *\n * This implies assertSet\n */\nfunction assertNotEmpty(value) {\n    assertSet(value);\n    if (typeof value === \"number\" && value === 0) {\n        throw new Error(\"must provide a non-zero value\");\n    }\n    else if (value.length === 0) {\n        throw new Error(\"must provide a non-empty value\");\n    }\n    return value;\n}\nexports.assertNotEmpty = assertNotEmpty;\n// optional uses the value or provides a default\nfunction optional(value, fallback) {\n    return value === undefined || value === null ? fallback : value;\n}\nexports.optional = optional;\n// may will run the transform if value is defined, otherwise returns undefined\nfunction may(transform, value) {\n    return value === undefined || value === null ? undefined : transform(value);\n}\nexports.may = may;\nfunction dictionaryToStringMap(obj) {\n    const out = new Map();\n    for (const key of Object.keys(obj)) {\n        const value = obj[key];\n        if (typeof value !== \"string\") {\n            throw new Error(\"Found dictionary value of type other than string\");\n        }\n        out.set(key, value);\n    }\n    return out;\n}\nexports.dictionaryToStringMap = dictionaryToStringMap;\nclass Integer {\n    static parse(input) {\n        const asInt = typeof input === \"number\" ? new math_1.Int53(input) : math_1.Int53.fromString(input);\n        return asInt.toNumber();\n    }\n    static encode(num) {\n        return new math_1.Int53(num).toString();\n    }\n}\nexports.Integer = Integer;\n// Encodings needed for hashing block headers\n// Several of these functions are inspired by https://github.com/nomic-io/js-tendermint/blob/tendermint-0.30/src/\n// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L193-L195\nfunction encodeString(s) {\n    const utf8 = (0, encoding_1.toUtf8)(s);\n    return Uint8Array.from([utf8.length, ...utf8]);\n}\nexports.encodeString = encodeString;\n// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L79-L87\nfunction encodeInt(n) {\n    // eslint-disable-next-line no-bitwise\n    return n >= 0x80 ? Uint8Array.from([(n & 0xff) | 0x80, ...encodeInt(n >> 7)]) : Uint8Array.from([n & 0xff]);\n}\nexports.encodeInt = encodeInt;\n// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L134-L178\nfunction encodeTime(time) {\n    const milliseconds = time.getTime();\n    const seconds = Math.floor(milliseconds / 1000);\n    const secondsArray = seconds ? [0x08, ...encodeInt(seconds)] : new Uint8Array();\n    const nanoseconds = (time.nanoseconds || 0) + (milliseconds % 1000) * 1e6;\n    const nanosecondsArray = nanoseconds ? [0x10, ...encodeInt(nanoseconds)] : new Uint8Array();\n    return Uint8Array.from([...secondsArray, ...nanosecondsArray]);\n}\nexports.encodeTime = encodeTime;\n// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L180-L187\nfunction encodeBytes(bytes) {\n    // Since we're only dealing with short byte arrays we don't need a full VarBuffer implementation yet\n    if (bytes.length >= 0x80)\n        throw new Error(\"Not implemented for byte arrays of length 128 or more\");\n    return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();\n}\nexports.encodeBytes = encodeBytes;\nfunction encodeVersion(version) {\n    const blockArray = version.block ? Uint8Array.from([0x08, ...encodeInt(version.block)]) : new Uint8Array();\n    const appArray = version.app ? Uint8Array.from([0x10, ...encodeInt(version.app)]) : new Uint8Array();\n    return Uint8Array.from([...blockArray, ...appArray]);\n}\nexports.encodeVersion = encodeVersion;\nfunction encodeBlockId(blockId) {\n    return Uint8Array.from([\n        0x0a,\n        blockId.hash.length,\n        ...blockId.hash,\n        0x12,\n        blockId.parts.hash.length + 4,\n        0x08,\n        blockId.parts.total,\n        0x12,\n        blockId.parts.hash.length,\n        ...blockId.parts.hash,\n    ]);\n}\nexports.encodeBlockId = encodeBlockId;\n//# sourceMappingURL=encodings.js.map"]},"metadata":{},"sourceType":"script"}