{"ast":null,"code":"import _objectSpread from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nvar _0n = BigInt(0);\nvar _1n = BigInt(1);\nvar _2n = BigInt(2);\nvar _3n = BigInt(3);\nvar _8n = BigInt(8);\nvar CURVE = Object.freeze({\n  a: _0n,\n  b: BigInt(7),\n  P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n  h: _1n,\n  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')\n});\nexport { CURVE };\nfunction weistrass(x) {\n  var a = CURVE.a,\n    b = CURVE.b;\n  var x2 = mod(x * x);\n  var x3 = mod(x2 * x);\n  return mod(x3 + a * x + b);\n}\nvar USE_ENDOMORPHISM = CURVE.a === _0n;\nvar ShaError = /*#__PURE__*/function (_Error) {\n  _inherits(ShaError, _Error);\n  var _super = _createSuper(ShaError);\n  function ShaError(message) {\n    _classCallCheck(this, ShaError);\n    return _super.call(this, message);\n  }\n  return _createClass(ShaError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar JacobianPoint = /*#__PURE__*/function () {\n  function JacobianPoint(x, y, z) {\n    _classCallCheck(this, JacobianPoint);\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  _createClass(JacobianPoint, [{\n    key: \"equals\",\n    value: function equals(other) {\n      if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');\n      var X1 = this.x,\n        Y1 = this.y,\n        Z1 = this.z;\n      var X2 = other.x,\n        Y2 = other.y,\n        Z2 = other.z;\n      var Z1Z1 = mod(Z1 * Z1);\n      var Z2Z2 = mod(Z2 * Z2);\n      var U1 = mod(X1 * Z2Z2);\n      var U2 = mod(X2 * Z1Z1);\n      var S1 = mod(mod(Y1 * Z2) * Z2Z2);\n      var S2 = mod(mod(Y2 * Z1) * Z1Z1);\n      return U1 === U2 && S1 === S2;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n  }, {\n    key: \"double\",\n    value: function double() {\n      var X1 = this.x,\n        Y1 = this.y,\n        Z1 = this.z;\n      var A = mod(X1 * X1);\n      var B = mod(Y1 * Y1);\n      var C = mod(B * B);\n      var x1b = X1 + B;\n      var D = mod(_2n * (mod(x1b * x1b) - A - C));\n      var E = mod(_3n * A);\n      var F = mod(E * E);\n      var X3 = mod(F - _2n * D);\n      var Y3 = mod(E * (D - X3) - _8n * C);\n      var Z3 = mod(_2n * Y1 * Z1);\n      return new JacobianPoint(X3, Y3, Z3);\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');\n      var X1 = this.x,\n        Y1 = this.y,\n        Z1 = this.z;\n      var X2 = other.x,\n        Y2 = other.y,\n        Z2 = other.z;\n      if (X2 === _0n || Y2 === _0n) return this;\n      if (X1 === _0n || Y1 === _0n) return other;\n      var Z1Z1 = mod(Z1 * Z1);\n      var Z2Z2 = mod(Z2 * Z2);\n      var U1 = mod(X1 * Z2Z2);\n      var U2 = mod(X2 * Z1Z1);\n      var S1 = mod(mod(Y1 * Z2) * Z2Z2);\n      var S2 = mod(mod(Y2 * Z1) * Z1Z1);\n      var H = mod(U2 - U1);\n      var r = mod(S2 - S1);\n      if (H === _0n) {\n        if (r === _0n) {\n          return this.double();\n        } else {\n          return JacobianPoint.ZERO;\n        }\n      }\n      var HH = mod(H * H);\n      var HHH = mod(H * HH);\n      var V = mod(U1 * HH);\n      var X3 = mod(r * r - HHH - _2n * V);\n      var Y3 = mod(r * (V - X3) - S1 * HHH);\n      var Z3 = mod(Z1 * Z2 * H);\n      return new JacobianPoint(X3, Y3, Z3);\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      return this.add(other.negate());\n    }\n  }, {\n    key: \"multiplyUnsafe\",\n    value: function multiplyUnsafe(scalar) {\n      var P0 = JacobianPoint.ZERO;\n      if (typeof scalar === 'bigint' && scalar === _0n) return P0;\n      var n = normalizeScalar(scalar);\n      if (n === _1n) return this;\n      if (!USE_ENDOMORPHISM) {\n        var p = P0;\n        var _d = this;\n        while (n > _0n) {\n          if (n & _1n) p = p.add(_d);\n          _d = _d.double();\n          n >>= _1n;\n        }\n        return p;\n      }\n      var _splitScalarEndo = splitScalarEndo(n),\n        k1neg = _splitScalarEndo.k1neg,\n        k1 = _splitScalarEndo.k1,\n        k2neg = _splitScalarEndo.k2neg,\n        k2 = _splitScalarEndo.k2;\n      var k1p = P0;\n      var k2p = P0;\n      var d = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n      return k1p.add(k2p);\n    }\n  }, {\n    key: \"precomputeWindow\",\n    value: function precomputeWindow(W) {\n      var windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n      var points = [];\n      var p = this;\n      var base = p;\n      for (var window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        for (var i = 1; i < Math.pow(2, W - 1); i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    }\n  }, {\n    key: \"wNAF\",\n    value: function wNAF(n, affinePoint) {\n      if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n      var W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n      if (256 % W) {\n        throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n      }\n      var precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n      if (!precomputes) {\n        precomputes = this.precomputeWindow(W);\n        if (affinePoint && W !== 1) {\n          precomputes = JacobianPoint.normalizeZ(precomputes);\n          pointPrecomputes.set(affinePoint, precomputes);\n        }\n      }\n      var p = JacobianPoint.ZERO;\n      var f = JacobianPoint.ZERO;\n      var windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n      var windowSize = Math.pow(2, W - 1);\n      var mask = BigInt(Math.pow(2, W) - 1);\n      var maxNumber = Math.pow(2, W);\n      var shiftBy = BigInt(W);\n      for (var window = 0; window < windows; window++) {\n        var offset = window * windowSize;\n        var wbits = Number(n & mask);\n        n >>= shiftBy;\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        if (wbits === 0) {\n          var pr = precomputes[offset];\n          if (window % 2) pr = pr.negate();\n          f = f.add(pr);\n        } else {\n          var cached = precomputes[offset + Math.abs(wbits) - 1];\n          if (wbits < 0) cached = cached.negate();\n          p = p.add(cached);\n        }\n      }\n      return {\n        p: p,\n        f: f\n      };\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar, affinePoint) {\n      var n = normalizeScalar(scalar);\n      var point;\n      var fake;\n      if (USE_ENDOMORPHISM) {\n        var _splitScalarEndo2 = splitScalarEndo(n),\n          k1neg = _splitScalarEndo2.k1neg,\n          k1 = _splitScalarEndo2.k1,\n          k2neg = _splitScalarEndo2.k2neg,\n          k2 = _splitScalarEndo2.k2;\n        var _this$wNAF = this.wNAF(k1, affinePoint),\n          k1p = _this$wNAF.p,\n          f1p = _this$wNAF.f;\n        var _this$wNAF2 = this.wNAF(k2, affinePoint),\n          k2p = _this$wNAF2.p,\n          f2p = _this$wNAF2.f;\n        if (k1neg) k1p = k1p.negate();\n        if (k2neg) k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        var _this$wNAF3 = this.wNAF(n, affinePoint),\n          p = _this$wNAF3.p,\n          f = _this$wNAF3.f;\n        point = p;\n        fake = f;\n      }\n      return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n  }, {\n    key: \"toAffine\",\n    value: function toAffine() {\n      var invZ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : invert(this.z);\n      var x = this.x,\n        y = this.y,\n        z = this.z;\n      var iz1 = invZ;\n      var iz2 = mod(iz1 * iz1);\n      var iz3 = mod(iz2 * iz1);\n      var ax = mod(x * iz2);\n      var ay = mod(y * iz3);\n      var zz = mod(z * iz1);\n      if (zz !== _1n) throw new Error('invZ was invalid');\n      return new Point(ax, ay);\n    }\n  }], [{\n    key: \"fromAffine\",\n    value: function fromAffine(p) {\n      if (!(p instanceof Point)) {\n        throw new TypeError('JacobianPoint#fromAffine: expected Point');\n      }\n      return new JacobianPoint(p.x, p.y, _1n);\n    }\n  }, {\n    key: \"toAffineBatch\",\n    value: function toAffineBatch(points) {\n      var toInv = invertBatch(points.map(function (p) {\n        return p.z;\n      }));\n      return points.map(function (p, i) {\n        return p.toAffine(toInv[i]);\n      });\n    }\n  }, {\n    key: \"normalizeZ\",\n    value: function normalizeZ(points) {\n      return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n  }]);\n  return JacobianPoint;\n}();\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nvar pointPrecomputes = new WeakMap();\nexport var Point = /*#__PURE__*/function () {\n  function Point(x, y) {\n    _classCallCheck(this, Point);\n    this.x = x;\n    this.y = y;\n  }\n  _createClass(Point, [{\n    key: \"_setWindowSize\",\n    value: function _setWindowSize(windowSize) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n  }, {\n    key: \"hasEvenY\",\n    value: function hasEvenY() {\n      return this.y % _2n === _0n;\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return hexToBytes(this.toHex(isCompressed));\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var x = numTo32bStr(this.x);\n      if (isCompressed) {\n        var prefix = this.hasEvenY() ? '02' : '03';\n        return \"\".concat(prefix).concat(x);\n      } else {\n        return \"04\".concat(x).concat(numTo32bStr(this.y));\n      }\n    }\n  }, {\n    key: \"toHexX\",\n    value: function toHexX() {\n      return this.toHex(true).slice(2);\n    }\n  }, {\n    key: \"toRawX\",\n    value: function toRawX() {\n      return this.toRawBytes(true).slice(1);\n    }\n  }, {\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var msg = 'Point is not on elliptic curve';\n      var x = this.x,\n        y = this.y;\n      if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);\n      var left = mod(y * y);\n      var right = weistrass(x);\n      if (mod(left - right) !== _0n) throw new Error(msg);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.x === other.x && this.y === other.y;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return new Point(this.x, mod(-this.y));\n    }\n  }, {\n    key: \"double\",\n    value: function double() {\n      return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      return this.add(other.negate());\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar) {\n      return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n  }, {\n    key: \"multiplyAndAddUnsafe\",\n    value: function multiplyAndAddUnsafe(Q, a, b) {\n      var P = JacobianPoint.fromAffine(this);\n      var aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n      var bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n      var sum = aP.add(bQ);\n      return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n  }], [{\n    key: \"fromCompressedHex\",\n    value: function fromCompressedHex(bytes) {\n      var isShort = bytes.length === 32;\n      var x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n      if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n      var y2 = weistrass(x);\n      var y = sqrtMod(y2);\n      var isYOdd = (y & _1n) === _1n;\n      if (isShort) {\n        if (isYOdd) y = mod(-y);\n      } else {\n        var isFirstByteOdd = (bytes[0] & 1) === 1;\n        if (isFirstByteOdd !== isYOdd) y = mod(-y);\n      }\n      var point = new Point(x, y);\n      point.assertValidity();\n      return point;\n    }\n  }, {\n    key: \"fromUncompressedHex\",\n    value: function fromUncompressedHex(bytes) {\n      var x = bytesToNumber(bytes.subarray(1, 33));\n      var y = bytesToNumber(bytes.subarray(33, 65));\n      var point = new Point(x, y);\n      point.assertValidity();\n      return point;\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      var bytes = ensureBytes(hex);\n      var len = bytes.length;\n      var header = bytes[0];\n      if (len === 32 || len === 33 && (header === 0x02 || header === 0x03)) {\n        return this.fromCompressedHex(bytes);\n      }\n      if (len === 65 && header === 0x04) return this.fromUncompressedHex(bytes);\n      throw new Error(\"Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not \".concat(len));\n    }\n  }, {\n    key: \"fromPrivateKey\",\n    value: function fromPrivateKey(privateKey) {\n      return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n  }, {\n    key: \"fromSignature\",\n    value: function fromSignature(msgHash, signature, recovery) {\n      msgHash = ensureBytes(msgHash);\n      var h = truncateHash(msgHash);\n      var _normalizeSignature = normalizeSignature(signature),\n        r = _normalizeSignature.r,\n        s = _normalizeSignature.s;\n      if (recovery !== 0 && recovery !== 1) {\n        throw new Error('Cannot recover signature: invalid recovery bit');\n      }\n      var prefix = recovery & 1 ? '03' : '02';\n      var R = Point.fromHex(prefix + numTo32bStr(r));\n      var n = CURVE.n;\n      var rinv = invert(r, n);\n      var u1 = mod(-h * rinv, n);\n      var u2 = mod(s * rinv, n);\n      var Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n      if (!Q) throw new Error('Cannot recover signature: point at infinify');\n      Q.assertValidity();\n      return Q;\n    }\n  }]);\n  return Point;\n}();\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n  return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n  if (data.length < 2 || data[0] !== 0x02) {\n    throw new Error(\"Invalid signature integer tag: \".concat(bytesToHex(data)));\n  }\n  var len = data[1];\n  var res = data.subarray(2, len + 2);\n  if (!len || res.length !== len) {\n    throw new Error(\"Invalid signature integer: wrong length\");\n  }\n  if (res[0] === 0x00 && res[1] <= 0x7f) {\n    throw new Error('Invalid signature integer: trailing length');\n  }\n  return {\n    data: bytesToNumber(res),\n    left: data.subarray(len + 2)\n  };\n}\nfunction parseDERSignature(data) {\n  if (data.length < 2 || data[0] != 0x30) {\n    throw new Error(\"Invalid signature tag: \".concat(bytesToHex(data)));\n  }\n  if (data[1] !== data.length - 2) {\n    throw new Error('Invalid signature: incorrect length');\n  }\n  var _parseDERInt = parseDERInt(data.subarray(2)),\n    r = _parseDERInt.data,\n    sBytes = _parseDERInt.left;\n  var _parseDERInt2 = parseDERInt(sBytes),\n    s = _parseDERInt2.data,\n    rBytesLeft = _parseDERInt2.left;\n  if (rBytesLeft.length) {\n    throw new Error(\"Invalid signature: left bytes after parsing: \".concat(bytesToHex(rBytesLeft)));\n  }\n  return {\n    r: r,\n    s: s\n  };\n}\nexport var Signature = /*#__PURE__*/function () {\n  function Signature(r, s) {\n    _classCallCheck(this, Signature);\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n  _createClass(Signature, [{\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var r = this.r,\n        s = this.s;\n      if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');\n      if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n  }, {\n    key: \"hasHighS\",\n    value: function hasHighS() {\n      var HALF = CURVE.n >> _1n;\n      return this.s > HALF;\n    }\n  }, {\n    key: \"normalizeS\",\n    value: function normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;\n    }\n  }, {\n    key: \"toDERRawBytes\",\n    value: function toDERRawBytes() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return hexToBytes(this.toDERHex(isCompressed));\n    }\n  }, {\n    key: \"toDERHex\",\n    value: function toDERHex() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var sHex = sliceDER(numberToHexUnpadded(this.s));\n      if (isCompressed) return sHex;\n      var rHex = sliceDER(numberToHexUnpadded(this.r));\n      var rLen = numberToHexUnpadded(rHex.length / 2);\n      var sLen = numberToHexUnpadded(sHex.length / 2);\n      var length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);\n      return \"30\".concat(length, \"02\").concat(rLen).concat(rHex, \"02\").concat(sLen).concat(sHex);\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      return this.toDERRawBytes();\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return this.toDERHex();\n    }\n  }, {\n    key: \"toCompactRawBytes\",\n    value: function toCompactRawBytes() {\n      return hexToBytes(this.toCompactHex());\n    }\n  }, {\n    key: \"toCompactHex\",\n    value: function toCompactHex() {\n      return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n  }], [{\n    key: \"fromCompact\",\n    value: function fromCompact(hex) {\n      var arr = hex instanceof Uint8Array;\n      var name = 'Signature.fromCompact';\n      if (typeof hex !== 'string' && !arr) throw new TypeError(\"\".concat(name, \": Expected string or Uint8Array\"));\n      var str = arr ? bytesToHex(hex) : hex;\n      if (str.length !== 128) throw new Error(\"\".concat(name, \": Expected 64-byte hex\"));\n      return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n  }, {\n    key: \"fromDER\",\n    value: function fromDER(hex) {\n      var arr = hex instanceof Uint8Array;\n      if (typeof hex !== 'string' && !arr) throw new TypeError(\"Signature.fromDER: Expected string or Uint8Array\");\n      var _parseDERSignature = parseDERSignature(arr ? hex : hexToBytes(hex)),\n        r = _parseDERSignature.r,\n        s = _parseDERSignature.s;\n      return new Signature(r, s);\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      return this.fromDER(hex);\n    }\n  }]);\n  return Signature;\n}();\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n  if (!arrays.every(function (b) {\n    return b instanceof Uint8Array;\n  })) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  var length = arrays.reduce(function (a, arr) {\n    return a + arr.length;\n  }, 0);\n  var result = new Uint8Array(length);\n  for (var i = 0, pad = 0; i < arrays.length; i++) {\n    var arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\nvar hexes = Array.from({\n  length: 256\n}, function (v, i) {\n  return i.toString(16).padStart(2, '0');\n});\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  var hex = '';\n  for (var i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\nvar POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n  if (typeof num !== 'bigint') throw new Error('Expected bigint');\n  if (!(_0n <= num && num < POW_2_256)) throw new Error('Expected number < 2^256');\n  return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n  var b = hexToBytes(numTo32bStr(num));\n  if (b.length !== 32) throw new Error('Error: expected 32 bytes');\n  return b;\n}\nfunction numberToHexUnpadded(num) {\n  var hex = num.toString(16);\n  return hex.length & 1 ? \"0\".concat(hex) : hex;\n}\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n  }\n  return BigInt(\"0x\".concat(hex));\n}\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n  var array = new Uint8Array(hex.length / 2);\n  for (var i = 0; i < array.length; i++) {\n    var j = i * 2;\n    var hexByte = hex.slice(j, j + 2);\n    var byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\nfunction bytesToNumber(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n  if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0) return BigInt(num);\n  if (typeof num === 'bigint' && isWithinCurveOrder(num)) return num;\n  throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a) {\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  var result = a % b;\n  return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n  var P = CURVE.P;\n  var res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= P;\n  }\n  return res;\n}\nfunction sqrtMod(x) {\n  var P = CURVE.P;\n  var _6n = BigInt(6);\n  var _11n = BigInt(11);\n  var _22n = BigInt(22);\n  var _23n = BigInt(23);\n  var _44n = BigInt(44);\n  var _88n = BigInt(88);\n  var b2 = x * x * x % P;\n  var b3 = b2 * b2 * x % P;\n  var b6 = pow2(b3, _3n) * b3 % P;\n  var b9 = pow2(b6, _3n) * b3 % P;\n  var b11 = pow2(b9, _2n) * b2 % P;\n  var b22 = pow2(b11, _11n) * b11 % P;\n  var b44 = pow2(b22, _22n) * b22 % P;\n  var b88 = pow2(b44, _44n) * b44 % P;\n  var b176 = pow2(b88, _88n) * b88 % P;\n  var b220 = pow2(b176, _44n) * b44 % P;\n  var b223 = pow2(b220, _3n) * b3 % P;\n  var t1 = pow2(b223, _23n) * b22 % P;\n  var t2 = pow2(t1, _6n) * b2 % P;\n  return pow2(t2, _2n);\n}\nfunction invert(number) {\n  var modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(\"invert: expected positive integers, got n=\".concat(number, \" mod=\").concat(modulo));\n  }\n  var a = mod(number, modulo);\n  var b = modulo;\n  var x = _0n,\n    y = _1n,\n    u = _1n,\n    v = _0n;\n  while (a !== _0n) {\n    var q = b / a;\n    var r = b % a;\n    var m = x - u * q;\n    var n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  var gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\nfunction invertBatch(nums) {\n  var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  var scratch = new Array(nums.length);\n  var lastMultiplied = nums.reduce(function (acc, num, i) {\n    if (num === _0n) return acc;\n    scratch[i] = acc;\n    return mod(acc * num, p);\n  }, _1n);\n  var inverted = invert(lastMultiplied, p);\n  nums.reduceRight(function (acc, num, i) {\n    if (num === _0n) return acc;\n    scratch[i] = mod(acc * scratch[i], p);\n    return mod(acc * num, p);\n  }, inverted);\n  return scratch;\n}\nvar divNearest = function divNearest(a, b) {\n  return (a + b / _2n) / b;\n};\nvar ENDO = {\n  a1: BigInt('0x3086d221a7d46bcde86c90e49284eb15'),\n  b1: -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'),\n  a2: BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),\n  b2: BigInt('0x3086d221a7d46bcde86c90e49284eb15'),\n  POW_2_128: BigInt('0x100000000000000000000000000000000')\n};\nfunction splitScalarEndo(k) {\n  var n = CURVE.n;\n  var a1 = ENDO.a1,\n    b1 = ENDO.b1,\n    a2 = ENDO.a2,\n    b2 = ENDO.b2,\n    POW_2_128 = ENDO.POW_2_128;\n  var c1 = divNearest(b2 * k, n);\n  var c2 = divNearest(-b1 * k, n);\n  var k1 = mod(k - c1 * a1 - c2 * a2, n);\n  var k2 = mod(-c1 * b1 - c2 * b2, n);\n  var k1neg = k1 > POW_2_128;\n  var k2neg = k2 > POW_2_128;\n  if (k1neg) k1 = n - k1;\n  if (k2neg) k2 = n - k2;\n  if (k1 > POW_2_128 || k2 > POW_2_128) {\n    throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n  }\n  return {\n    k1neg: k1neg,\n    k1: k1,\n    k2neg: k2neg,\n    k2: k2\n  };\n}\nfunction truncateHash(hash) {\n  var n = CURVE.n;\n  var byteLength = hash.length;\n  var delta = byteLength * 8 - 256;\n  var h = bytesToNumber(hash);\n  if (delta > 0) h = h >> BigInt(delta);\n  if (h >= n) h -= n;\n  return h;\n}\nvar _sha256Sync;\nvar _hmacSha256Sync;\nvar HmacDrbg = /*#__PURE__*/function () {\n  function HmacDrbg() {\n    _classCallCheck(this, HmacDrbg);\n    this.v = new Uint8Array(32).fill(1);\n    this.k = new Uint8Array(32).fill(0);\n    this.counter = 0;\n  }\n  _createClass(HmacDrbg, [{\n    key: \"hmac\",\n    value: function hmac() {\n      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        values[_key2] = arguments[_key2];\n      }\n      return utils.hmacSha256.apply(utils, [this.k].concat(values));\n    }\n  }, {\n    key: \"hmacSync\",\n    value: function hmacSync() {\n      for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        values[_key3] = arguments[_key3];\n      }\n      return _hmacSha256Sync.apply(void 0, [this.k].concat(values));\n    }\n  }, {\n    key: \"checkSync\",\n    value: function checkSync() {\n      if (typeof _hmacSha256Sync !== 'function') throw new ShaError('hmacSha256Sync needs to be set');\n    }\n  }, {\n    key: \"incr\",\n    value: function incr() {\n      if (this.counter >= 1000) throw new Error('Tried 1,000 k values for sign(), all were invalid');\n      this.counter += 1;\n    }\n  }, {\n    key: \"reseed\",\n    value: function () {\n      var _reseed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var seed,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                seed = _args.length > 0 && _args[0] !== undefined ? _args[0] : new Uint8Array();\n                _context.next = 3;\n                return this.hmac(this.v, Uint8Array.from([0x00]), seed);\n              case 3:\n                this.k = _context.sent;\n                _context.next = 6;\n                return this.hmac(this.v);\n              case 6:\n                this.v = _context.sent;\n                if (!(seed.length === 0)) {\n                  _context.next = 9;\n                  break;\n                }\n                return _context.abrupt(\"return\");\n              case 9:\n                _context.next = 11;\n                return this.hmac(this.v, Uint8Array.from([0x01]), seed);\n              case 11:\n                this.k = _context.sent;\n                _context.next = 14;\n                return this.hmac(this.v);\n              case 14:\n                this.v = _context.sent;\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function reseed() {\n        return _reseed.apply(this, arguments);\n      }\n      return reseed;\n    }()\n  }, {\n    key: \"reseedSync\",\n    value: function reseedSync() {\n      var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n      this.checkSync();\n      this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n      this.v = this.hmacSync(this.v);\n      if (seed.length === 0) return;\n      this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n      this.v = this.hmacSync(this.v);\n    }\n  }, {\n    key: \"generate\",\n    value: function () {\n      var _generate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.incr();\n                _context2.next = 3;\n                return this.hmac(this.v);\n              case 3:\n                this.v = _context2.sent;\n                return _context2.abrupt(\"return\", this.v);\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function generate() {\n        return _generate.apply(this, arguments);\n      }\n      return generate;\n    }()\n  }, {\n    key: \"generateSync\",\n    value: function generateSync() {\n      this.checkSync();\n      this.incr();\n      this.v = this.hmacSync(this.v);\n      return this.v;\n    }\n  }]);\n  return HmacDrbg;\n}();\nfunction isWithinCurveOrder(num) {\n  return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n  return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d) {\n  var k = bytesToNumber(kBytes);\n  if (!isWithinCurveOrder(k)) return;\n  var n = CURVE.n;\n  var q = Point.BASE.multiply(k);\n  var r = mod(q.x, n);\n  if (r === _0n) return;\n  var s = mod(invert(k, n) * mod(m + d * r, n), n);\n  if (s === _0n) return;\n  var sig = new Signature(r, s);\n  var recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n  return {\n    sig: sig,\n    recovery: recovery\n  };\n}\nfunction normalizePrivateKey(key) {\n  var num;\n  if (typeof key === 'bigint') {\n    num = key;\n  } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n    num = BigInt(key);\n  } else if (typeof key === 'string') {\n    if (key.length !== 64) throw new Error('Expected 32 bytes of private key');\n    num = hexToNumber(key);\n  } else if (key instanceof Uint8Array) {\n    if (key.length !== 32) throw new Error('Expected 32 bytes of private key');\n    num = bytesToNumber(key);\n  } else {\n    throw new TypeError('Expected valid private key');\n  }\n  if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');\n  return num;\n}\nfunction normalizePublicKey(publicKey) {\n  if (publicKey instanceof Point) {\n    publicKey.assertValidity();\n    return publicKey;\n  } else {\n    return Point.fromHex(publicKey);\n  }\n}\nfunction normalizeSignature(signature) {\n  if (signature instanceof Signature) {\n    signature.assertValidity();\n    return signature;\n  }\n  try {\n    return Signature.fromDER(signature);\n  } catch (error) {\n    return Signature.fromCompact(signature);\n  }\n}\nexport function getPublicKey(privateKey) {\n  var isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery) {\n  var isCompressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n  var arr = item instanceof Uint8Array;\n  var str = typeof item === 'string';\n  var len = (arr || str) && item.length;\n  if (arr) return len === 33 || len === 65;\n  if (str) return len === 66 || len === 130;\n  if (item instanceof Point) return true;\n  return false;\n}\nexport function getSharedSecret(privateA, publicB) {\n  var isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (isProbPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');\n  if (!isProbPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');\n  var b = normalizePublicKey(publicB);\n  b.assertValidity();\n  return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n  var slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;\n  return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n  var z1 = bits2int(bytes);\n  var z2 = mod(z1, CURVE.n);\n  return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n  return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n  if (msgHash == null) throw new Error(\"sign: expected valid message hash, not \\\"\".concat(msgHash, \"\\\"\"));\n  var h1 = ensureBytes(msgHash);\n  var d = normalizePrivateKey(privateKey);\n  var seedArgs = [int2octets(d), bits2octets(h1)];\n  if (extraEntropy != null) {\n    if (extraEntropy === true) extraEntropy = utils.randomBytes(32);\n    var e = ensureBytes(extraEntropy);\n    if (e.length !== 32) throw new Error('sign: Expected 32 bytes of extra data');\n    seedArgs.push(e);\n  }\n  var seed = concatBytes.apply(void 0, seedArgs);\n  var m = bits2int(h1);\n  return {\n    seed: seed,\n    m: m,\n    d: d\n  };\n}\nfunction finalizeSig(recSig, opts) {\n  var sig = recSig.sig,\n    recovery = recSig.recovery;\n  var _Object$assign = Object.assign({\n      canonical: true,\n      der: true\n    }, opts),\n    canonical = _Object$assign.canonical,\n    der = _Object$assign.der,\n    recovered = _Object$assign.recovered;\n  if (canonical && sig.hasHighS()) {\n    sig = sig.normalizeS();\n    recovery ^= 1;\n  }\n  var hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n  return recovered ? [hashed, recovery] : hashed;\n}\nfunction sign(_x, _x2) {\n  return _sign.apply(this, arguments);\n}\nfunction _sign() {\n  _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(msgHash, privKey) {\n    var opts,\n      _initSigArgs2,\n      seed,\n      m,\n      d,\n      sig,\n      drbg,\n      _args7 = arguments;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            opts = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : {};\n            _initSigArgs2 = initSigArgs(msgHash, privKey, opts.extraEntropy), seed = _initSigArgs2.seed, m = _initSigArgs2.m, d = _initSigArgs2.d;\n            drbg = new HmacDrbg();\n            _context7.next = 5;\n            return drbg.reseed(seed);\n          case 5:\n            _context7.t0 = kmdToSig;\n            _context7.next = 8;\n            return drbg.generate();\n          case 8:\n            _context7.t1 = _context7.sent;\n            _context7.t2 = m;\n            _context7.t3 = d;\n            if (sig = (0, _context7.t0)(_context7.t1, _context7.t2, _context7.t3)) {\n              _context7.next = 16;\n              break;\n            }\n            _context7.next = 14;\n            return drbg.reseed();\n          case 14:\n            _context7.next = 5;\n            break;\n          case 16:\n            return _context7.abrupt(\"return\", finalizeSig(sig, opts));\n          case 17:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _sign.apply(this, arguments);\n}\nfunction signSync(msgHash, privKey) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _initSigArgs = initSigArgs(msgHash, privKey, opts.extraEntropy),\n    seed = _initSigArgs.seed,\n    m = _initSigArgs.m,\n    d = _initSigArgs.d;\n  var sig;\n  var drbg = new HmacDrbg();\n  drbg.reseedSync(seed);\n  while (!(sig = kmdToSig(drbg.generateSync(), m, d))) {\n    drbg.reseedSync();\n  }\n  return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nvar vopts = {\n  strict: true\n};\nexport function verify(signature, msgHash, publicKey) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : vopts;\n  var sig;\n  try {\n    sig = normalizeSignature(signature);\n    msgHash = ensureBytes(msgHash);\n  } catch (error) {\n    return false;\n  }\n  var _sig = sig,\n    r = _sig.r,\n    s = _sig.s;\n  if (opts.strict && sig.hasHighS()) return false;\n  var h = truncateHash(msgHash);\n  var P;\n  try {\n    P = normalizePublicKey(publicKey);\n  } catch (error) {\n    return false;\n  }\n  var n = CURVE.n;\n  var sinv = invert(s, n);\n  var u1 = mod(h * sinv, n);\n  var u2 = mod(r * sinv, n);\n  var R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n  if (!R) return false;\n  var v = mod(R.x, n);\n  return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n  return mod(bytesToNumber(ch), CURVE.n);\n}\nvar SchnorrSignature = /*#__PURE__*/function () {\n  function SchnorrSignature(r, s) {\n    _classCallCheck(this, SchnorrSignature);\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n  _createClass(SchnorrSignature, [{\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var r = this.r,\n        s = this.s;\n      if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error('Invalid signature');\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      return hexToBytes(this.toHex());\n    }\n  }], [{\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      var bytes = ensureBytes(hex);\n      if (bytes.length !== 64) throw new TypeError(\"SchnorrSignature.fromHex: expected 64 bytes, not \".concat(bytes.length));\n      var r = bytesToNumber(bytes.subarray(0, 32));\n      var s = bytesToNumber(bytes.subarray(32, 64));\n      return new SchnorrSignature(r, s);\n    }\n  }]);\n  return SchnorrSignature;\n}();\nfunction schnorrGetPublicKey(privateKey) {\n  return Point.fromPrivateKey(privateKey).toRawX();\n}\nvar InternalSchnorrSignature = /*#__PURE__*/function () {\n  function InternalSchnorrSignature(message, privateKey) {\n    var auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : utils.randomBytes();\n    _classCallCheck(this, InternalSchnorrSignature);\n    if (message == null) throw new TypeError(\"sign: Expected valid message, not \\\"\".concat(message, \"\\\"\"));\n    this.m = ensureBytes(message);\n    var _this$getScalar = this.getScalar(normalizePrivateKey(privateKey)),\n      x = _this$getScalar.x,\n      scalar = _this$getScalar.scalar;\n    this.px = x;\n    this.d = scalar;\n    this.rand = ensureBytes(auxRand);\n    if (this.rand.length !== 32) throw new TypeError('sign: Expected 32 bytes of aux randomness');\n  }\n  _createClass(InternalSchnorrSignature, [{\n    key: \"getScalar\",\n    value: function getScalar(priv) {\n      var point = Point.fromPrivateKey(priv);\n      var scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n      return {\n        point: point,\n        scalar: scalar,\n        x: point.toRawX()\n      };\n    }\n  }, {\n    key: \"initNonce\",\n    value: function initNonce(d, t0h) {\n      return numTo32b(d ^ bytesToNumber(t0h));\n    }\n  }, {\n    key: \"finalizeNonce\",\n    value: function finalizeNonce(k0h) {\n      var k0 = mod(bytesToNumber(k0h), CURVE.n);\n      if (k0 === _0n) throw new Error('sign: Creation of signature failed. k is zero');\n      var _this$getScalar2 = this.getScalar(k0),\n        R = _this$getScalar2.point,\n        rx = _this$getScalar2.x,\n        k = _this$getScalar2.scalar;\n      return {\n        R: R,\n        rx: rx,\n        k: k\n      };\n    }\n  }, {\n    key: \"finalizeSig\",\n    value: function finalizeSig(R, k, e, d) {\n      return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      throw new Error('sign: Invalid signature produced');\n    }\n  }, {\n    key: \"calc\",\n    value: function () {\n      var _calc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var m, d, px, rand, tag, t, _this$finalizeNonce, R, rx, k, e, sig;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                m = this.m, d = this.d, px = this.px, rand = this.rand;\n                tag = utils.taggedHash;\n                _context3.t0 = this;\n                _context3.t1 = d;\n                _context3.next = 6;\n                return tag(TAGS.aux, rand);\n              case 6:\n                _context3.t2 = _context3.sent;\n                t = _context3.t0.initNonce.call(_context3.t0, _context3.t1, _context3.t2);\n                _context3.t3 = this;\n                _context3.next = 11;\n                return tag(TAGS.nonce, t, px, m);\n              case 11:\n                _context3.t4 = _context3.sent;\n                _this$finalizeNonce = _context3.t3.finalizeNonce.call(_context3.t3, _context3.t4);\n                R = _this$finalizeNonce.R;\n                rx = _this$finalizeNonce.rx;\n                k = _this$finalizeNonce.k;\n                _context3.t5 = schnorrChallengeFinalize;\n                _context3.next = 19;\n                return tag(TAGS.challenge, rx, px, m);\n              case 19:\n                _context3.t6 = _context3.sent;\n                e = (0, _context3.t5)(_context3.t6);\n                sig = this.finalizeSig(R, k, e, d);\n                _context3.next = 24;\n                return schnorrVerify(sig, m, px);\n              case 24:\n                if (_context3.sent) {\n                  _context3.next = 26;\n                  break;\n                }\n                this.error();\n              case 26:\n                return _context3.abrupt(\"return\", sig);\n              case 27:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function calc() {\n        return _calc.apply(this, arguments);\n      }\n      return calc;\n    }()\n  }, {\n    key: \"calcSync\",\n    value: function calcSync() {\n      var m = this.m,\n        d = this.d,\n        px = this.px,\n        rand = this.rand;\n      var tag = utils.taggedHashSync;\n      var t = this.initNonce(d, tag(TAGS.aux, rand));\n      var _this$finalizeNonce2 = this.finalizeNonce(tag(TAGS.nonce, t, px, m)),\n        R = _this$finalizeNonce2.R,\n        rx = _this$finalizeNonce2.rx,\n        k = _this$finalizeNonce2.k;\n      var e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n      var sig = this.finalizeSig(R, k, e, d);\n      if (!schnorrVerifySync(sig, m, px)) this.error();\n      return sig;\n    }\n  }]);\n  return InternalSchnorrSignature;\n}();\nfunction schnorrSign(_x3, _x4, _x5) {\n  return _schnorrSign.apply(this, arguments);\n}\nfunction _schnorrSign() {\n  _schnorrSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(msg, privKey, auxRand) {\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            return _context8.abrupt(\"return\", new InternalSchnorrSignature(msg, privKey, auxRand).calc());\n          case 1:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _schnorrSign.apply(this, arguments);\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n  return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n  var raw = signature instanceof SchnorrSignature;\n  var sig = raw ? signature : SchnorrSignature.fromHex(signature);\n  if (raw) sig.assertValidity();\n  return _objectSpread(_objectSpread({}, sig), {}, {\n    m: ensureBytes(message),\n    P: normalizePublicKey(publicKey)\n  });\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n  var R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n  if (!R || !R.hasEvenY() || R.x !== r) return false;\n  return true;\n}\nfunction schnorrVerify(_x6, _x7, _x8) {\n  return _schnorrVerify.apply(this, arguments);\n}\nfunction _schnorrVerify() {\n  _schnorrVerify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(signature, message, publicKey) {\n    var _initSchnorrVerify2, r, s, m, P, e;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.prev = 0;\n            _initSchnorrVerify2 = initSchnorrVerify(signature, message, publicKey), r = _initSchnorrVerify2.r, s = _initSchnorrVerify2.s, m = _initSchnorrVerify2.m, P = _initSchnorrVerify2.P;\n            _context9.t0 = schnorrChallengeFinalize;\n            _context9.next = 5;\n            return utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m);\n          case 5:\n            _context9.t1 = _context9.sent;\n            e = (0, _context9.t0)(_context9.t1);\n            return _context9.abrupt(\"return\", finalizeSchnorrVerify(r, P, s, e));\n          case 10:\n            _context9.prev = 10;\n            _context9.t2 = _context9[\"catch\"](0);\n            return _context9.abrupt(\"return\", false);\n          case 13:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9, null, [[0, 10]]);\n  }));\n  return _schnorrVerify.apply(this, arguments);\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n  try {\n    var _initSchnorrVerify = initSchnorrVerify(signature, message, publicKey),\n      r = _initSchnorrVerify.r,\n      s = _initSchnorrVerify.s,\n      m = _initSchnorrVerify.m,\n      P = _initSchnorrVerify.P;\n    var e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n    return finalizeSchnorrVerify(r, P, s, e);\n  } catch (error) {\n    if (error instanceof ShaError) throw error;\n    return false;\n  }\n}\nexport var schnorr = {\n  Signature: SchnorrSignature,\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  signSync: schnorrSignSync,\n  verifySync: schnorrVerifySync\n};\nPoint.BASE._setWindowSize(8);\nvar crypto = {\n  node: nodeCrypto,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\nvar TAGS = {\n  challenge: 'BIP0340/challenge',\n  aux: 'BIP0340/aux',\n  nonce: 'BIP0340/nonce'\n};\nvar TAGGED_HASH_PREFIXES = {};\nexport var utils = {\n  bytesToHex: bytesToHex,\n  hexToBytes: hexToBytes,\n  concatBytes: concatBytes,\n  mod: mod,\n  invert: invert,\n  isValidPrivateKey: function isValidPrivateKey(privateKey) {\n    try {\n      normalizePrivateKey(privateKey);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  },\n  _bigintTo32Bytes: numTo32b,\n  _normalizePrivateKey: normalizePrivateKey,\n  hashToPrivateKey: function hashToPrivateKey(hash) {\n    hash = ensureBytes(hash);\n    if (hash.length < 40 || hash.length > 1024) throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n    var num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n    return numTo32b(num);\n  },\n  randomBytes: function randomBytes() {\n    var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      var randomBytes = crypto.node.randomBytes;\n      return Uint8Array.from(randomBytes(bytesLength));\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: function randomPrivateKey() {\n    return utils.hashToPrivateKey(utils.randomBytes(40));\n  },\n  sha256: function () {\n    var _sha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n      var _len4,\n        messages,\n        _key4,\n        buffer,\n        createHash,\n        hash,\n        _args4 = arguments;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              for (_len4 = _args4.length, messages = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                messages[_key4] = _args4[_key4];\n              }\n              if (!crypto.web) {\n                _context4.next = 8;\n                break;\n              }\n              _context4.next = 4;\n              return crypto.web.subtle.digest('SHA-256', concatBytes.apply(void 0, messages));\n            case 4:\n              buffer = _context4.sent;\n              return _context4.abrupt(\"return\", new Uint8Array(buffer));\n            case 8:\n              if (!crypto.node) {\n                _context4.next = 15;\n                break;\n              }\n              createHash = crypto.node.createHash;\n              hash = createHash('sha256');\n              messages.forEach(function (m) {\n                return hash.update(m);\n              });\n              return _context4.abrupt(\"return\", Uint8Array.from(hash.digest()));\n            case 15:\n              throw new Error(\"The environment doesn't have sha256 function\");\n            case 16:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    function sha256() {\n      return _sha.apply(this, arguments);\n    }\n    return sha256;\n  }(),\n  hmacSha256: function () {\n    var _hmacSha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key) {\n      var _len5,\n        messages,\n        _key5,\n        ckey,\n        message,\n        buffer,\n        createHmac,\n        hash,\n        _args5 = arguments;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              for (_len5 = _args5.length, messages = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                messages[_key5 - 1] = _args5[_key5];\n              }\n              if (!crypto.web) {\n                _context5.next = 12;\n                break;\n              }\n              _context5.next = 4;\n              return crypto.web.subtle.importKey('raw', key, {\n                name: 'HMAC',\n                hash: {\n                  name: 'SHA-256'\n                }\n              }, false, ['sign']);\n            case 4:\n              ckey = _context5.sent;\n              message = concatBytes.apply(void 0, messages);\n              _context5.next = 8;\n              return crypto.web.subtle.sign('HMAC', ckey, message);\n            case 8:\n              buffer = _context5.sent;\n              return _context5.abrupt(\"return\", new Uint8Array(buffer));\n            case 12:\n              if (!crypto.node) {\n                _context5.next = 19;\n                break;\n              }\n              createHmac = crypto.node.createHmac;\n              hash = createHmac('sha256', key);\n              messages.forEach(function (m) {\n                return hash.update(m);\n              });\n              return _context5.abrupt(\"return\", Uint8Array.from(hash.digest()));\n            case 19:\n              throw new Error(\"The environment doesn't have hmac-sha256 function\");\n            case 20:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n    function hmacSha256(_x9) {\n      return _hmacSha.apply(this, arguments);\n    }\n    return hmacSha256;\n  }(),\n  sha256Sync: undefined,\n  hmacSha256Sync: undefined,\n  taggedHash: function () {\n    var _taggedHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(tag) {\n      var tagP,\n        tagH,\n        _len6,\n        messages,\n        _key6,\n        _args6 = arguments;\n      return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              tagP = TAGGED_HASH_PREFIXES[tag];\n              if (!(tagP === undefined)) {\n                _context6.next = 7;\n                break;\n              }\n              _context6.next = 4;\n              return utils.sha256(Uint8Array.from(tag, function (c) {\n                return c.charCodeAt(0);\n              }));\n            case 4:\n              tagH = _context6.sent;\n              tagP = concatBytes(tagH, tagH);\n              TAGGED_HASH_PREFIXES[tag] = tagP;\n            case 7:\n              for (_len6 = _args6.length, messages = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n                messages[_key6 - 1] = _args6[_key6];\n              }\n              return _context6.abrupt(\"return\", utils.sha256.apply(utils, [tagP].concat(messages)));\n            case 9:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n    function taggedHash(_x10) {\n      return _taggedHash.apply(this, arguments);\n    }\n    return taggedHash;\n  }(),\n  taggedHashSync: function taggedHashSync(tag) {\n    if (typeof _sha256Sync !== 'function') throw new ShaError('sha256Sync is undefined, you need to set it');\n    var tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n      var tagH = _sha256Sync(Uint8Array.from(tag, function (c) {\n        return c.charCodeAt(0);\n      }));\n      tagP = concatBytes(tagH, tagH);\n      TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    for (var _len7 = arguments.length, messages = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      messages[_key7 - 1] = arguments[_key7];\n    }\n    return _sha256Sync.apply(void 0, [tagP].concat(messages));\n  },\n  precompute: function precompute() {\n    var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n    var cached = point === Point.BASE ? point : new Point(point.x, point.y);\n    cached._setWindowSize(windowSize);\n    cached.multiply(_3n);\n    return cached;\n  }\n};\nObject.defineProperties(utils, {\n  sha256Sync: {\n    configurable: false,\n    get: function get() {\n      return _sha256Sync;\n    },\n    set: function set(val) {\n      if (!_sha256Sync) _sha256Sync = val;\n    }\n  },\n  hmacSha256Sync: {\n    configurable: false,\n    get: function get() {\n      return _hmacSha256Sync;\n    },\n    set: function set(val) {\n      if (!_hmacSha256Sync) _hmacSha256Sync = val;\n    }\n  }\n});","map":{"version":3,"names":["nodeCrypto","_0n","BigInt","_1n","_2n","_3n","_8n","CURVE","Object","freeze","a","b","P","n","h","Gx","Gy","beta","weistrass","x","x2","mod","x3","USE_ENDOMORPHISM","ShaError","message","Error","JacobianPoint","y","z","other","TypeError","X1","Y1","Z1","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","A","B","C","x1b","D","E","F","X3","Y3","Z3","H","r","double","ZERO","HH","HHH","V","add","negate","scalar","P0","normalizeScalar","p","d","splitScalarEndo","k1neg","k1","k2neg","k2","k1p","k2p","W","windows","points","base","window","push","i","affinePoint","equals","BASE","Point","_WINDOW_SIZE","precomputes","pointPrecomputes","get","precomputeWindow","normalizeZ","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","pr","cached","Math","abs","point","fake","wNAF","f1p","f2p","invZ","invert","iz1","iz2","iz3","ax","ay","zz","toInv","invertBatch","map","toAffine","toAffineBatch","fromAffine","WeakMap","delete","isCompressed","hexToBytes","toHex","numTo32bStr","prefix","hasEvenY","slice","toRawBytes","msg","isValidFieldElement","left","right","multiply","Q","aP","multiplyUnsafe","bQ","sum","undefined","bytes","isShort","length","bytesToNumber","subarray","y2","sqrtMod","isYOdd","isFirstByteOdd","assertValidity","hex","ensureBytes","len","header","fromCompressedHex","fromUncompressedHex","privateKey","normalizePrivateKey","msgHash","signature","recovery","truncateHash","normalizeSignature","s","R","fromHex","rinv","u1","u2","multiplyAndAddUnsafe","sliceDER","parseInt","parseDERInt","data","bytesToHex","res","parseDERSignature","sBytes","rBytesLeft","Signature","isWithinCurveOrder","HALF","hasHighS","toDERHex","sHex","numberToHexUnpadded","rHex","rLen","sLen","toDERRawBytes","toCompactHex","arr","Uint8Array","name","str","hexToNumber","fromDER","concatBytes","arrays","every","reduce","result","pad","hexes","Array","from","v","toString","padStart","uint8a","POW_2_256","num","numTo32b","array","j","hexByte","byte","isNaN","isSafeInteger","pow2","power","_6n","_11n","_22n","_23n","_44n","_88n","b2","b3","b6","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","number","modulo","u","q","m","gcd","nums","scratch","lastMultiplied","acc","inverted","reduceRight","divNearest","ENDO","a1","b1","a2","POW_2_128","k","c1","c2","hash","byteLength","delta","_sha256Sync","_hmacSha256Sync","HmacDrbg","fill","counter","values","utils","hmacSha256","seed","hmac","checkSync","hmacSync","incr","kmdToSig","kBytes","sig","key","normalizePublicKey","publicKey","error","fromCompact","getPublicKey","fromPrivateKey","recoverPublicKey","fromSignature","isProbPub","item","getSharedSecret","privateA","publicB","bits2int","bits2octets","z1","z2","int2octets","initSigArgs","extraEntropy","h1","seedArgs","randomBytes","e","finalizeSig","recSig","opts","assign","canonical","der","recovered","normalizeS","hashed","toCompactRawBytes","sign","privKey","drbg","reseed","generate","signSync","reseedSync","generateSync","vopts","strict","verify","sinv","schnorrChallengeFinalize","ch","SchnorrSignature","schnorrGetPublicKey","toRawX","InternalSchnorrSignature","auxRand","getScalar","px","rand","priv","t0h","k0h","k0","rx","tag","taggedHash","TAGS","aux","t","initNonce","nonce","finalizeNonce","challenge","schnorrVerify","taggedHashSync","schnorrVerifySync","schnorrSign","calc","schnorrSignSync","calcSync","initSchnorrVerify","raw","finalizeSchnorrVerify","schnorr","verifySync","_setWindowSize","crypto","node","web","self","TAGGED_HASH_PREFIXES","isValidPrivateKey","_bigintTo32Bytes","_normalizePrivateKey","hashToPrivateKey","bytesLength","getRandomValues","randomPrivateKey","sha256","messages","subtle","digest","buffer","createHash","forEach","update","importKey","ckey","createHmac","sha256Sync","hmacSha256Sync","tagP","c","charCodeAt","tagH","precompute","defineProperties","configurable","val"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/@noble/secp256k1/lib/esm/index.js"],"sourcesContent":["/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n});\nexport { CURVE };\nfunction weistrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.ZERO;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weistrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, 33));\n        const y = bytesToNumber(bytes.subarray(33, 65));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === 65 && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        msgHash = ensureBytes(msgHash);\n        const h = truncateHash(msgHash);\n        const { r, s } = normalizeSignature(signature);\n        if (recovery !== 0 && recovery !== 1) {\n            throw new Error('Cannot recover signature: invalid recovery bit');\n        }\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(r));\n        const { n } = CURVE;\n        const rinv = invert(r, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? '02' : '03';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weistrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nexport class Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;\n    }\n    toDERRawBytes(isCompressed = false) {\n        return hexToBytes(this.toDERHex(isCompressed));\n    }\n    toDERHex(isCompressed = false) {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        if (isCompressed)\n            return sHex;\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const rLen = numberToHexUnpadded(rHex.length / 2);\n        const sLen = numberToHexUnpadded(sHex.length / 2);\n        const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b) => b instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    if (!(_0n <= num && num < POW_2_256))\n        throw new Error('Expected number < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32)\n        throw new Error('Error: expected 32 bytes');\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    return pow2(t2, _2n);\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst ENDO = {\n    a1: BigInt('0x3086d221a7d46bcde86c90e49284eb15'),\n    b1: -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'),\n    a2: BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),\n    b2: BigInt('0x3086d221a7d46bcde86c90e49284eb15'),\n    POW_2_128: BigInt('0x100000000000000000000000000000000'),\n};\nfunction splitScalarEndo(k) {\n    const { n } = CURVE;\n    const { a1, b1, a2, b2, POW_2_128 } = ENDO;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\n    const k1neg = k1 > POW_2_128;\n    const k2neg = k2 > POW_2_128;\n    if (k1neg)\n        k1 = n - k1;\n    if (k2neg)\n        k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\n        throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction truncateHash(hash) {\n    const { n } = CURVE;\n    const byteLength = hash.length;\n    const delta = byteLength * 8 - 256;\n    let h = bytesToNumber(hash);\n    if (delta > 0)\n        h = h >> BigInt(delta);\n    if (h >= n)\n        h -= n;\n    return h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor() {\n        this.v = new Uint8Array(32).fill(1);\n        this.k = new Uint8Array(32).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== 'function')\n            throw new ShaError('hmacSha256Sync needs to be set');\n    }\n    incr() {\n        if (this.counter >= 1000)\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        this.v = await this.hmac(this.v);\n        return this.v;\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        this.v = this.hmacSync(this.v);\n        return this.v;\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d) {\n    const k = bytesToNumber(kBytes);\n    if (!isWithinCurveOrder(k))\n        return;\n    const { n } = CURVE;\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(invert(k, n) * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    const sig = new Signature(r, s);\n    const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 64)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== 32)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nexport function getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === 33 || len === 65;\n    if (str)\n        return len === 66 || len === 130;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isProbPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(32);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== 32)\n            throw new Error('sign: Expected 32 bytes of extra data');\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    let { sig, recovery } = recSig;\n    const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    if (canonical && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    await drbg.reseed(seed);\n    while (!(sig = kmdToSig(await drbg.generate(), m, d)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    drbg.reseedSync(seed);\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = { strict: true };\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = utils.randomBytes()) {\n        if (message == null)\n            throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32)\n            throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return { point, scalar, x: point.toRawX() };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n)\n            throw new Error('sign: Creation of signature failed. k is zero');\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return { R, rx, k };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error('sign: Invalid signature produced');\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!(await schnorrVerify(sig, m, px)))\n            this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px))\n            this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        if (error instanceof ShaError)\n            throw error;\n        return false;\n    }\n}\nexport const schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.hashToPrivateKey(utils.randomBytes(40));\n    },\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof _sha256Sync !== 'function')\n            throw new ShaError('sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n};\nObject.defineProperties(utils, {\n    sha256Sync: {\n        configurable: false,\n        get() {\n            return _sha256Sync;\n        },\n        set(val) {\n            if (!_sha256Sync)\n                _sha256Sync = val;\n        },\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get() {\n            return _hmacSha256Sync;\n        },\n        set(val) {\n            if (!_hmacSha256Sync)\n                _hmacSha256Sync = val;\n        },\n    },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}