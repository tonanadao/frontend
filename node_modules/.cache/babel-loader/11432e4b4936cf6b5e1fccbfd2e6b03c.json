{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;\nconst stream_1 = require(\"@cosmjs/stream\");\nconst xstream_1 = require(\"xstream\");\nconst streamingsocket_1 = require(\"./streamingsocket\");\nvar ConnectionStatus;\n(function (ConnectionStatus) {\n  ConnectionStatus[ConnectionStatus[\"Unconnected\"] = 0] = \"Unconnected\";\n  ConnectionStatus[ConnectionStatus[\"Connecting\"] = 1] = \"Connecting\";\n  ConnectionStatus[ConnectionStatus[\"Connected\"] = 2] = \"Connected\";\n  ConnectionStatus[ConnectionStatus[\"Disconnected\"] = 3] = \"Disconnected\";\n})(ConnectionStatus = exports.ConnectionStatus || (exports.ConnectionStatus = {}));\n/**\n * A wrapper around StreamingSocket that can queue requests.\n */\nclass QueueingStreamingSocket {\n  constructor(url) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n    let reconnectedHandler = arguments.length > 2 ? arguments[2] : undefined;\n    this.queue = [];\n    this.isProcessingQueue = false;\n    this.url = url;\n    this.timeout = timeout;\n    this.reconnectedHandler = reconnectedHandler;\n    const eventProducer = {\n      start: listener => this.eventProducerListener = listener,\n      stop: () => this.eventProducerListener = undefined\n    };\n    this.events = xstream_1.Stream.create(eventProducer);\n    this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);\n    this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);\n    this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n    this.socket.events.subscribe({\n      next: event => {\n        if (!this.eventProducerListener) throw new Error(\"No event producer listener set\");\n        this.eventProducerListener.next(event);\n      },\n      error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)\n    });\n  }\n  connect() {\n    this.connectionStatusProducer.update(ConnectionStatus.Connecting);\n    this.socket.connected.then(async () => {\n      this.connectionStatusProducer.update(ConnectionStatus.Connected);\n      return this.processQueue();\n    }, () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected));\n    this.socket.connect();\n  }\n  disconnect() {\n    this.connectionStatusProducer.update(ConnectionStatus.Disconnected);\n    this.socket.disconnect();\n  }\n  reconnect() {\n    this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n    this.socket.events.subscribe({\n      next: event => {\n        if (!this.eventProducerListener) throw new Error(\"No event producer listener set\");\n        this.eventProducerListener.next(event);\n      },\n      error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)\n    });\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.socket.connected.then(() => {\n      if (this.reconnectedHandler) {\n        this.reconnectedHandler();\n      }\n    });\n    this.connect();\n  }\n  getQueueLength() {\n    return this.queue.length;\n  }\n  queueRequest(request) {\n    this.queue.push(request);\n    // We don’t need to wait for the queue to be processed.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.processQueue();\n  }\n  async processQueue() {\n    if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {\n      return;\n    }\n    this.isProcessingQueue = true;\n    let request;\n    while (request = this.queue.shift()) {\n      try {\n        await this.socket.send(request);\n        this.isProcessingQueue = false;\n      } catch (error) {\n        // Probably the connection is down; will try again automatically when reconnected.\n        this.queue.unshift(request);\n        this.isProcessingQueue = false;\n        return;\n      }\n    }\n  }\n}\nexports.QueueingStreamingSocket = QueueingStreamingSocket;","map":{"version":3,"sources":["../src/queueingstreamingsocket.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;\nconst stream_1 = require(\"@cosmjs/stream\");\nconst xstream_1 = require(\"xstream\");\nconst streamingsocket_1 = require(\"./streamingsocket\");\nvar ConnectionStatus;\n(function (ConnectionStatus) {\n    ConnectionStatus[ConnectionStatus[\"Unconnected\"] = 0] = \"Unconnected\";\n    ConnectionStatus[ConnectionStatus[\"Connecting\"] = 1] = \"Connecting\";\n    ConnectionStatus[ConnectionStatus[\"Connected\"] = 2] = \"Connected\";\n    ConnectionStatus[ConnectionStatus[\"Disconnected\"] = 3] = \"Disconnected\";\n})(ConnectionStatus = exports.ConnectionStatus || (exports.ConnectionStatus = {}));\n/**\n * A wrapper around StreamingSocket that can queue requests.\n */\nclass QueueingStreamingSocket {\n    constructor(url, timeout = 10000, reconnectedHandler) {\n        this.queue = [];\n        this.isProcessingQueue = false;\n        this.url = url;\n        this.timeout = timeout;\n        this.reconnectedHandler = reconnectedHandler;\n        const eventProducer = {\n            start: (listener) => (this.eventProducerListener = listener),\n            stop: () => (this.eventProducerListener = undefined),\n        };\n        this.events = xstream_1.Stream.create(eventProducer);\n        this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);\n        this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);\n        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n        this.socket.events.subscribe({\n            next: (event) => {\n                if (!this.eventProducerListener)\n                    throw new Error(\"No event producer listener set\");\n                this.eventProducerListener.next(event);\n            },\n            error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected),\n        });\n    }\n    connect() {\n        this.connectionStatusProducer.update(ConnectionStatus.Connecting);\n        this.socket.connected.then(async () => {\n            this.connectionStatusProducer.update(ConnectionStatus.Connected);\n            return this.processQueue();\n        }, () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected));\n        this.socket.connect();\n    }\n    disconnect() {\n        this.connectionStatusProducer.update(ConnectionStatus.Disconnected);\n        this.socket.disconnect();\n    }\n    reconnect() {\n        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n        this.socket.events.subscribe({\n            next: (event) => {\n                if (!this.eventProducerListener)\n                    throw new Error(\"No event producer listener set\");\n                this.eventProducerListener.next(event);\n            },\n            error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected),\n        });\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.socket.connected.then(() => {\n            if (this.reconnectedHandler) {\n                this.reconnectedHandler();\n            }\n        });\n        this.connect();\n    }\n    getQueueLength() {\n        return this.queue.length;\n    }\n    queueRequest(request) {\n        this.queue.push(request);\n        // We don’t need to wait for the queue to be processed.\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.processQueue();\n    }\n    async processQueue() {\n        if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {\n            return;\n        }\n        this.isProcessingQueue = true;\n        let request;\n        while ((request = this.queue.shift())) {\n            try {\n                await this.socket.send(request);\n                this.isProcessingQueue = false;\n            }\n            catch (error) {\n                // Probably the connection is down; will try again automatically when reconnected.\n                this.queue.unshift(request);\n                this.isProcessingQueue = false;\n                return;\n            }\n        }\n    }\n}\nexports.QueueingStreamingSocket = QueueingStreamingSocket;\n//# sourceMappingURL=queueingstreamingsocket.js.map"]},"metadata":{},"sourceType":"script"}